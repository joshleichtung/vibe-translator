# Story 2.4: Parse MusicGen-Chord Response into Musical Data

## Status
Draft

## Story
**As a** developer,
**I want** a parser that extracts chord progressions and tempo from API response,
**so that** I have structured data ready for audio synthesis.

## Acceptance Criteria
1. Parser extracts chord notation (ROOT:TYPE format, e.g., "C:maj", "G:min7")
2. Tempo/BPM extracted from response metadata
3. Chord sequence converted to array of objects with root, type, duration
4. Invalid chords filtered or converted to valid types
5. Parser handles missing or malformed data gracefully
6. Unit tests validate parser with sample API responses
7. TypeScript types defined for parsed musical data structure

## Tasks / Subtasks
- [ ] Define parsed data types (AC: 7)
  - [ ] Create `src/types/music.ts` for music theory types
  - [ ] Define Chord interface (root, type, duration)
  - [ ] Define ChordProgression interface
  - [ ] Define valid chord types enum
  - [ ] Define valid note roots enum
- [ ] Create chord parser function (AC: 1, 3, 4)
  - [ ] Create `src/lib/parser.ts` for parsing logic
  - [ ] Implement `parseChordNotation(notation: string)` function
  - [ ] Extract ROOT:TYPE format using regex
  - [ ] Convert to Chord objects with root, type, duration
  - [ ] Filter invalid chord notations
  - [ ] Normalize chord type aliases (maj → major, min → minor)
- [ ] Create response parser function (AC: 2, 5)
  - [ ] Implement `parseMusicGenResponse(response)` function
  - [ ] Extract chord progression from output string
  - [ ] Extract tempo/BPM from metadata or default to 120
  - [ ] Handle missing fields with defaults
  - [ ] Handle malformed response gracefully
  - [ ] Return structured ChordProgression object
- [ ] Write unit tests (AC: 6)
  - [ ] Create `src/lib/__tests__/parser.test.ts`
  - [ ] Test valid chord notation parsing
  - [ ] Test invalid chord filtering
  - [ ] Test missing data handling
  - [ ] Test malformed response handling
  - [ ] Test chord type normalization

## Dev Notes

### Tech Stack Reference
- **Testing**: Vitest (matches Vite ecosystem)
- **Types**: TypeScript strict mode
- **Parsing**: Regex for chord notation extraction
- **Validation**: Enum-based chord/note validation

### Type Definitions
```typescript
// src/types/music.ts
export enum ChordRoot {
  C = 'C',
  Cs = 'C#',
  Db = 'Db',
  D = 'D',
  Ds = 'D#',
  Eb = 'Eb',
  E = 'E',
  F = 'F',
  Fs = 'F#',
  Gb = 'Gb',
  G = 'G',
  Gs = 'G#',
  Ab = 'Ab',
  A = 'A',
  As = 'A#',
  Bb = 'Bb',
  B = 'B',
}

export enum ChordType {
  Major = 'major',
  Minor = 'minor',
  Diminished = 'diminished',
  Augmented = 'augmented',
  Major7 = 'major7',
  Minor7 = 'minor7',
  Dominant7 = 'dominant7',
  Sus2 = 'sus2',
  Sus4 = 'sus4',
}

export interface Chord {
  root: ChordRoot;
  type: ChordType;
  duration: number; // in beats
}

export interface ChordProgression {
  chords: Chord[];
  tempo: number; // BPM
  timeSignature: [number, number]; // e.g., [4, 4]
}
```

### Parser Implementation
```typescript
// src/lib/parser.ts
import type { Chord, ChordProgression, ChordRoot, ChordType } from '@/types/music';
import type { MusicGenChordResponse } from '@/types/musicgen';

const CHORD_REGEX = /([A-G][#b]?):(\w+)/g;

const CHORD_TYPE_ALIASES: Record<string, ChordType> = {
  'maj': ChordType.Major,
  'major': ChordType.Major,
  'min': ChordType.Minor,
  'minor': ChordType.Minor,
  'm': ChordType.Minor,
  'dim': ChordType.Diminished,
  'aug': ChordType.Augmented,
  'maj7': ChordType.Major7,
  'min7': ChordType.Minor7,
  'm7': ChordType.Minor7,
  'dom7': ChordType.Dominant7,
  '7': ChordType.Dominant7,
  'sus2': ChordType.Sus2,
  'sus4': ChordType.Sus4,
};

export function parseChordNotation(notation: string): Chord | null {
  const matches = [...notation.matchAll(CHORD_REGEX)];

  if (matches.length === 0) return null;

  const [, root, typeStr] = matches[0];
  const type = CHORD_TYPE_ALIASES[typeStr.toLowerCase()];

  if (!type || !Object.values(ChordRoot).includes(root as ChordRoot)) {
    console.warn(`Invalid chord notation: ${notation}`);
    return null;
  }

  return {
    root: root as ChordRoot,
    type,
    duration: 4, // default to whole note (4 beats)
  };
}

export function parseMusicGenResponse(
  response: MusicGenChordResponse
): ChordProgression {
  const outputText = Array.isArray(response.output)
    ? response.output.join(' ')
    : response.output;

  const chordMatches = outputText.match(CHORD_REGEX) || [];

  const chords = chordMatches
    .map(parseChordNotation)
    .filter((chord): chord is Chord => chord !== null);

  // Default to 120 BPM if not specified
  const tempo = 120;

  return {
    chords,
    tempo,
    timeSignature: [4, 4],
  };
}
```

### Chord Notation Examples
Valid formats to parse:
- `C:maj` → C major
- `G:min7` → G minor 7
- `F:major` → F major
- `Am:min` → A minor
- `D:7` → D dominant 7

Invalid formats to filter:
- `X:maj` → Invalid root note
- `C:xyz` → Invalid chord type
- `invalid` → No ROOT:TYPE format

### Unit Test Structure
```typescript
// src/lib/__tests__/parser.test.ts
import { describe, it, expect } from 'vitest';
import { parseChordNotation, parseMusicGenResponse } from '../parser';
import { ChordRoot, ChordType } from '@/types/music';

describe('parseChordNotation', () => {
  it('parses valid major chord', () => {
    const chord = parseChordNotation('C:maj');
    expect(chord).toEqual({
      root: ChordRoot.C,
      type: ChordType.Major,
      duration: 4,
    });
  });

  it('filters invalid root note', () => {
    const chord = parseChordNotation('X:maj');
    expect(chord).toBeNull();
  });

  // Add more test cases...
});

describe('parseMusicGenResponse', () => {
  it('parses valid response with chord progression', () => {
    const response = {
      output: 'C:maj G:min D:7 F:major',
      status: 'succeeded' as const,
    };

    const progression = parseMusicGenResponse(response);
    expect(progression.chords).toHaveLength(4);
    expect(progression.tempo).toBe(120);
  });

  // Add more test cases...
});
```

### Edge Cases to Handle
- Empty output string → return empty chords array
- Malformed chord notation → filter out, don't crash
- Mixed valid/invalid chords → keep valid, filter invalid
- No tempo metadata → default to 120 BPM
- Array vs string output → handle both formats

### Testing Commands
```bash
npm run test                # Run all tests
npm run test:watch          # Watch mode for development
npm run test:coverage       # Generate coverage report
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 0.1 | Initial story creation from PRD Epic 2 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
**Created:**
_To be populated by dev agent_

**Modified:**
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
