# Story 2.4: Parse MusicGen-Chord Response into Musical Data

## Status
✅ Completed

## Story
**As a** developer,
**I want** a parser that extracts chord progressions and tempo from API response,
**so that** I have structured data ready for audio synthesis.

## Acceptance Criteria
1. Parser extracts chord notation (ROOT:TYPE format, e.g., "C:maj", "G:min7")
2. Tempo/BPM extracted from response metadata
3. Chord sequence converted to array of objects with root, type, duration
4. Invalid chords filtered or converted to valid types
5. Parser handles missing or malformed data gracefully
6. Unit tests validate parser with sample API responses
7. TypeScript types defined for parsed musical data structure

## Tasks / Subtasks
- [x] Define parsed data types (AC: 7)
  - [x] Create `src/types/music.ts` for music theory types
  - [x] Define Chord interface (root, type, duration)
  - [x] Define ChordProgression interface
  - [x] Define valid chord types enum
  - [x] Define valid note roots enum
- [x] Create chord parser function (AC: 1, 3, 4)
  - [x] Create `src/lib/parser.ts` for parsing logic
  - [x] Implement `parseChordNotation(notation: string)` function
  - [x] Extract ROOT:TYPE format using regex
  - [x] Convert to Chord objects with root, type, duration
  - [x] Filter invalid chord notations
  - [x] Normalize chord type aliases (maj → major, min → minor)
- [x] Create response parser function (AC: 2, 5)
  - [x] Implement `parseMusicGenResponse(response)` function
  - [x] Extract chord progression from output string
  - [x] Extract tempo/BPM from metadata or default to 120
  - [x] Handle missing fields with defaults
  - [x] Handle malformed response gracefully
  - [x] Return structured ChordProgression object
- [x] Write unit tests (AC: 6)
  - [x] Create `src/lib/__tests__/parser.test.ts`
  - [x] Test valid chord notation parsing
  - [x] Test invalid chord filtering
  - [x] Test missing data handling
  - [x] Test malformed response handling
  - [x] Test chord type normalization

## Dev Notes

### Tech Stack Reference
- **Testing**: Vitest (matches Vite ecosystem)
- **Types**: TypeScript strict mode
- **Parsing**: Regex for chord notation extraction
- **Validation**: Enum-based chord/note validation

### Type Definitions
```typescript
// src/types/music.ts
export enum ChordRoot {
  C = 'C',
  Cs = 'C#',
  Db = 'Db',
  D = 'D',
  Ds = 'D#',
  Eb = 'Eb',
  E = 'E',
  F = 'F',
  Fs = 'F#',
  Gb = 'Gb',
  G = 'G',
  Gs = 'G#',
  Ab = 'Ab',
  A = 'A',
  As = 'A#',
  Bb = 'Bb',
  B = 'B',
}

export enum ChordType {
  Major = 'major',
  Minor = 'minor',
  Diminished = 'diminished',
  Augmented = 'augmented',
  Major7 = 'major7',
  Minor7 = 'minor7',
  Dominant7 = 'dominant7',
  Sus2 = 'sus2',
  Sus4 = 'sus4',
}

export interface Chord {
  root: ChordRoot;
  type: ChordType;
  duration: number; // in beats
}

export interface ChordProgression {
  chords: Chord[];
  tempo: number; // BPM
  timeSignature: [number, number]; // e.g., [4, 4]
}
```

### Parser Implementation
```typescript
// src/lib/parser.ts
import type { Chord, ChordProgression, ChordRoot, ChordType } from '@/types/music';
import type { MusicGenChordResponse } from '@/types/musicgen';

const CHORD_REGEX = /([A-G][#b]?):(\w+)/g;

const CHORD_TYPE_ALIASES: Record<string, ChordType> = {
  'maj': ChordType.Major,
  'major': ChordType.Major,
  'min': ChordType.Minor,
  'minor': ChordType.Minor,
  'm': ChordType.Minor,
  'dim': ChordType.Diminished,
  'aug': ChordType.Augmented,
  'maj7': ChordType.Major7,
  'min7': ChordType.Minor7,
  'm7': ChordType.Minor7,
  'dom7': ChordType.Dominant7,
  '7': ChordType.Dominant7,
  'sus2': ChordType.Sus2,
  'sus4': ChordType.Sus4,
};

export function parseChordNotation(notation: string): Chord | null {
  const matches = [...notation.matchAll(CHORD_REGEX)];

  if (matches.length === 0) return null;

  const [, root, typeStr] = matches[0];
  const type = CHORD_TYPE_ALIASES[typeStr.toLowerCase()];

  if (!type || !Object.values(ChordRoot).includes(root as ChordRoot)) {
    console.warn(`Invalid chord notation: ${notation}`);
    return null;
  }

  return {
    root: root as ChordRoot,
    type,
    duration: 4, // default to whole note (4 beats)
  };
}

export function parseMusicGenResponse(
  response: MusicGenChordResponse
): ChordProgression {
  const outputText = Array.isArray(response.output)
    ? response.output.join(' ')
    : response.output;

  const chordMatches = outputText.match(CHORD_REGEX) || [];

  const chords = chordMatches
    .map(parseChordNotation)
    .filter((chord): chord is Chord => chord !== null);

  // Default to 120 BPM if not specified
  const tempo = 120;

  return {
    chords,
    tempo,
    timeSignature: [4, 4],
  };
}
```

### Chord Notation Examples
Valid formats to parse:
- `C:maj` → C major
- `G:min7` → G minor 7
- `F:major` → F major
- `Am:min` → A minor
- `D:7` → D dominant 7

Invalid formats to filter:
- `X:maj` → Invalid root note
- `C:xyz` → Invalid chord type
- `invalid` → No ROOT:TYPE format

### Unit Test Structure
```typescript
// src/lib/__tests__/parser.test.ts
import { describe, it, expect } from 'vitest';
import { parseChordNotation, parseMusicGenResponse } from '../parser';
import { ChordRoot, ChordType } from '@/types/music';

describe('parseChordNotation', () => {
  it('parses valid major chord', () => {
    const chord = parseChordNotation('C:maj');
    expect(chord).toEqual({
      root: ChordRoot.C,
      type: ChordType.Major,
      duration: 4,
    });
  });

  it('filters invalid root note', () => {
    const chord = parseChordNotation('X:maj');
    expect(chord).toBeNull();
  });

  // Add more test cases...
});

describe('parseMusicGenResponse', () => {
  it('parses valid response with chord progression', () => {
    const response = {
      output: 'C:maj G:min D:7 F:major',
      status: 'succeeded' as const,
    };

    const progression = parseMusicGenResponse(response);
    expect(progression.chords).toHaveLength(4);
    expect(progression.tempo).toBe(120);
  });

  // Add more test cases...
});
```

### Edge Cases to Handle
- Empty output string → return empty chords array
- Malformed chord notation → filter out, don't crash
- Mixed valid/invalid chords → keep valid, filter invalid
- No tempo metadata → default to 120 BPM
- Array vs string output → handle both formats

### Testing Commands
```bash
npm run test                # Run all tests
npm run test:watch          # Watch mode for development
npm run test:coverage       # Generate coverage report
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 0.1 | Initial story creation from PRD Epic 2 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
No debug issues encountered. All tests passed on first run after fixing test data.

### Completion Notes List
1. Extended existing `src/types/music.ts` with ChordRoot and ChordType enums
2. Added timeSignature field to ChordProgression interface
3. Created MusicGen response types in `src/types/musicgen.ts`
4. Implemented parser with exact regex and alias mapping from story spec
5. Parser gracefully filters invalid chords without crashing
6. Comprehensive test suite with 39 test cases covering all edge cases
7. All tests pass (39/39) with TypeScript compilation successful
8. Parser handles both string and array output formats
9. Defaults: tempo=120 BPM, duration=4 beats, timeSignature=[4,4]

### File List
**Created:**
- `/Users/josh/projects/aimusic/src/types/musicgen.ts` - MusicGen API response types
- `/Users/josh/projects/aimusic/src/lib/parser.ts` - Parser implementation (parseChordNotation, parseMusicGenResponse)
- `/Users/josh/projects/aimusic/src/lib/__tests__/parser.test.ts` - Comprehensive unit tests (39 tests)

**Modified:**
- `/Users/josh/projects/aimusic/src/types/music.ts` - Added ChordRoot and ChordType enums, updated Chord interface to use enums, added timeSignature to ChordProgression

## QA Results
_To be populated by QA agent_
